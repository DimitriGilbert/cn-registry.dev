################################################################################
# Library: Formedible - LLM Knowledge Base
# Version: 2.1 (Source-audited with examples)
# Date: 2025-07-19
################################################################################

### üö® CRITICAL REMINDERS FOR LLM AGENTS
---
1.  **STATE ACCESS**: Form state (`isSubmitting`, `isValid`, `values`, etc.) is **NOT** a direct return value. Access it via the `form` object: `form.state.isSubmitting`, `form.state.isValid`.
2.  **AUTO-RENDERING**: The `<Form />` component handles rendering, layout, and submission automatically. You do not need to manually create `<button type="submit">`.
3.  **SCHEMA IS KING**: The Zod `schema` in `useFormedible` options drives validation. The `name` in `FieldConfig` MUST match a key in the Zod schema.
4.  **MANUAL MODE**: To render fields manually, omit the `fields` array from options and use the returned `form` instance with your own components (e.g., `<form.Field>...`).

### üöÄ PRIMARY API: `useFormedible<TFormValues>(options)`
---
- **Description**: A declarative hook wrapping TanStack Form and shadcn/ui for rapid, schema-driven form development.
- **Returns**: `{ form, Form, ...pagination }`
    - **`form`**: The raw TanStack Form instance. Use for manual rendering or accessing the full TanStack Form API (`form.state`, `form.setFieldValue`, etc.).
    - **`Form`**: A React component that auto-renders the entire form UI.
    - **Pagination**:
        - `currentPage: number`
        - `totalPages: number`
        - `goToNextPage(): void`
        - `goToPreviousPage(): void`
        - `setCurrentPageWithValidation(page: number): void`
        - `isFirstPage: boolean`
        - `isLastPage: boolean`
        - `progressValue: number` (0-100)

### ‚öôÔ∏è CONFIGURATION: `UseFormedibleOptions<TFormValues>`
---
**Core:**
- `fields?: FieldConfig[]` - Array of field definitions for auto-rendering. Omit for manual mode.
- `schema?: z.ZodSchema<TFormValues>` - Zod schema for validation and type inference.
- `formOptions?: Partial<TanStackFormOptions>` - Pass-through options for TanStack Form.
  - `defaultValues: TFormValues` - **Required**.
  - `onSubmit: (props: { value: TFormValues; formApi: FormedibleFormApi<TFormValues> }) => void | Promise<void>` - **Required**.
- `disabled?: boolean` - Disables the entire form.
- `loading?: boolean` - Puts the form in a loading state.

**UI & Layout:**
- `submitLabel?: string` - Text for the final submit button.
- `nextLabel?`, `previousLabel?`: string - Labels for multi-page navigation.
- `formClassName?: string`, `fieldClassName?: string` - Custom CSS classes.
- `showSubmitButton?: boolean` - (Default: `true`) Toggle visibility of submit/next buttons.
- `layout?: { type: "grid" | "flex" | ...; columns?: number; gap?: string; }` - Configure form-level layout.
- `tabs?: Array<{ id: string; label: string; description?: string; }>` - Enables a tab-based layout.

**Multi-Page:**
- `pages?: PageConfig[]` - `Array<{ page: number; title?: string; description?: string; }>`
- `progress?: ProgressConfig` - ` { showSteps?: boolean; showPercentage?: boolean; }`
- `onPageChange?: (page: number, direction: "next" | "previous") => void`

**Advanced Features:**
- `conditionalSections?: Array<{ condition: (values: TFormValues) => boolean; fields: string[]; }>`
- `crossFieldValidation?: Array<{ fields: string[]; validator: (values: Partial<TFormValues>) => string | null; message: string; }>`
- `asyncValidation?: { [fieldName: string]: { validator: (value: any) => Promise<string | null>; debounceMs?: number; } }`
- `persistence?: { key: string; storage: "localStorage" | "sessionStorage"; restoreOnMount?: boolean; }`
- `analytics?: { onFieldFocus?: ..., onFormAbandon?: ..., ... }`

**Extensibility:**
- `defaultComponents?: { [fieldType: string]: React.ComponentType<FieldComponentProps> }`
- `globalWrapper?: React.ComponentType<{ children: React.ReactNode; field: FieldConfig }>`

### üß© INTERFACE: `FieldConfig`
---
**Core:**
- `name: string` - **Required**. Key in `TFormValues`, must match schema.
- `type: string` - **Required**. See "Supported Field Types".
- `label?: string`, `placeholder?: string`, `description?: string`
- `conditional?: (values: TFormValues) => boolean`

**Layout & Structure:**
- `page?: number` - Page number for multi-page forms.
- `tab?: string` - Associates field with a tab `id`.
- `group?: string` - Groups fields visually under a sub-heading.
- `section?: { title?: string; description?: string; collapsible?: boolean; defaultExpanded?: boolean; }`

**Options & Data:**
- `options?: Array<{value: string; label: string}> | string[] | (values: TFormValues) => Array<{...}>` - For `select`, `radio`, `multiSelect`, `autocomplete`.

**Field-Specific Configurations:**
- `arrayConfig?: { itemType: string; ...; sortable?: boolean; objectConfig?: { fields: FieldConfig[]; ... } }`
- `objectConfig?: { fields: FieldConfig[]; ... }`
- `autocompleteConfig?: { asyncOptions?: (query: string) => Promise<...>; ... }`
- `dateConfig?: { minDate?: Date; showTime?: boolean; ... }`
- `fileConfig?: { multiple?: boolean; maxSize?: number; ... }`
- `maskedInputConfig?: { mask: string | ((value: string) => string); ... }`
- `multiSelectConfig?: { searchable?: boolean; creatable?: boolean; ... }`
- `passwordConfig?: { showToggle?: boolean; strengthMeter?: boolean; ... }`
- `phoneConfig?: { defaultCountry?: string; ... }`
- `sliderConfig?: { min?: number; max?: number; step?: number; ... }`
- `textareaConfig?: { rows?: number; maxLength?: number; showWordCount?: boolean; ... }`

### üìã SUPPORTED FIELD TYPES
---
`text`, `email`, `password`, `url`, `textarea`, `select`, `multiSelect`, `checkbox`, `switch`, `radio`, `number`, `date`, `slider`, `rating`, `phone`, `colorPicker`, `file`, `array`, `object`, `autocomplete`, `duration`, `location`, `masked`.

---
### üìö USAGE PATTERNS & EXAMPLES
---

#### Pattern 1: Basic Auto-Generated Form
The most common use case. Define a schema and fields, then render `<Form />`.

```tsx
import { useFormedible } from "@/hooks/use-formedible";
import { z } from "zod";

const contactSchema = z.object({
  name: z.string().min(2, "Name is too short"),
  email: z.string().email("Invalid email"),
});

export function ContactForm() {
  const { Form } = useFormedible({
    schema: contactSchema,
    fields: [
      { name: "name", type: "text", label: "Full Name", placeholder: "John Doe" },
      { name: "email", type: "email", label: "Email", placeholder: "john@example.com" },
    ],
    formOptions: {
      defaultValues: { name: "", email: "" },
      onSubmit: async ({ value }) => {
        console.log("Form submitted:", value);
      },
    },
  });

  return <Form />;
}
```

#### Pattern 2: Multi-Page Wizard
Use the `page` property in `FieldConfig` and define `pages` in the main options.

```tsx
const { Form } = useFormedible({
  schema: registrationSchema,
  fields: [
    // Page 1
    { name: "firstName", type: "text", label: "First Name", page: 1 },
    { name: "lastName", type: "text", label: "Last Name", page: 1 },
    // Page 2
    { name: "email", type: "email", label: "Email Address", page: 2 },
    { name: "phone", type: "phone", label: "Phone Number", page: 2 },
  ],
  pages: [
    { page: 1, title: "Personal Information", description: "Tell us about yourself" },
    { page: 2, title: "Contact Details", description: "How can we reach you?" },
  ],
  progress: { showSteps: true, showPercentage: true },
  persistence: { key: "reg-form", storage: "localStorage", restoreOnMount: true },
  formOptions: {
    defaultValues: { firstName: "", lastName: "", email: "", phone: "" },
    onSubmit: async ({ value }) => console.log(value),
  },
});

return <Form />;
```

#### Pattern 3: Conditional Fields
Use the `conditional` property on a field to show/hide it based on other form values.

```tsx
const { Form } = useFormedible({
  schema: dynamicSchema,
  fields: [
    { name: "userType", type: "select", label: "User Type", options: ["individual", "business"] },
    // Show only for business users
    {
      name: "companyName",
      type: "text",
      label: "Company Name",
      conditional: (values) => values.userType === "business",
    },
  ],
  formOptions: {
    defaultValues: { userType: "individual", companyName: "" },
    onSubmit: async ({ value }) => console.log(value),
  },
});

return <Form />;
```

#### Pattern 4: Dynamic Options
Provide a function to the `options` property to make selections dependent on other form values.

```tsx
const { Form } = useFormedible({
  schema: locationSchema,
  fields: [
    { name: "country", type: "select", label: "Country", options: ["us", "ca"] },
    {
      name: "state",
      type: "select",
      label: "State/Province",
      conditional: (values) => !!values.country,
      options: (values) => { // This function re-runs when dependencies change
        if (values.country === "us") return ["California", "New York"];
        if (values.country === "ca") return ["Ontario", "Quebec"];
        return [];
      },
    },
  ],
  formOptions: { /* ... */ },
});
```

#### Pattern 5: Manual Field Rendering
For maximum layout control, omit the `fields` array and use the `form` instance directly. The `<Form>` component still provides the `<form>` element and `onSubmit` handling.

```tsx
import { TextField } from "@/components/formedible/fields/text-field"; // Import a field component
import { Button } from "@/components/ui/button";

const { form, Form } = useFormedible<FormValues>({
  schema: formSchema,
  formOptions: {
    defaultValues: { name: "" },
    onSubmit: async ({ value }) => console.log("Submitted:", value),
  },
});

return (
  <Form>
    <form.Field name="name">
      {(fieldApi) => (
        <TextField
          fieldApi={fieldApi}
          label="Name"
          placeholder="Your Name"
        />
      )}
    </form.Field>
    <form.Subscribe selector={(state) => [state.canSubmit, state.isSubmitting]}>
      {([canSubmit, isSubmitting]) => (
        <Button type="submit" disabled={!canSubmit || isSubmitting}>
          {isSubmitting ? "..." : "Submit"}
        </Button>
      )}
    </form.Subscribe>
  </Form>
);
```